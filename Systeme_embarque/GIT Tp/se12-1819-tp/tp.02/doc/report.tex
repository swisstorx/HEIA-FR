\input{Commands.tex}

\title{Système Embarqués II, Journal, TP.02:\\ Introduction à la programmation modulaire en C} 
\author{\textsl{Marc} \textsc{Roten} \\ \textsl{Sven} \textsc{Rouvinez}}
\date{}

\begin{document}
    \begin{titlepage}
        \begin{center}
            \includegraphics[scale=.3]{heia-fr-logo.png}\\[1.3cm]
            
            \rule{\linewidth}{0.3mm} \\[0.3cm]
            {\huge \bfseries Système embarqués \\[0.5cm]} 
           % {\Large Effet photoélectrique}\\[0.2cm]
            \rule{\linewidth}{0.3mm} \\[0.8cm]
            \noindent
            \begin{minipage}[t]{0.4\textwidth}
                \begin{flushleft} \large
                    \emph{Auteurs :}\\
                    \theauthor
                \end{flushleft}
            \end{minipage}
            \begin{minipage}[t]{0.4\textwidth} 
                \begin{flushright} \large
                    \emph{Professeur:}\\
                    \textsl{Daniel} \textsc{Gachet}\\ 
                \end{flushright} 
                \vfill
            \end{minipage}\\[1.3cm]
            \includegraphics[scale=0.6]{1.JPG}\\[1.5cm]
            \vspace*{1\baselineskip}
            \today \\[0.7cm]
        \end{center}
    \end{titlepage}
    \tableofcontents
    \clearpage
% \insertImage{Img/1.PNG}{echelle pour l'image (source = 1)}{texte dessous l'image}{référence vers l'objet}

\section{Pourrait-on se passer des fichiers d'entête (header files) en C ?} 
Oui il est possible de se passer des fichiers d'entête, il suffirait de mettre les signatures dans les fichiers source tout en haut

\section{\#pragma once}
Il permet d'éviter un import multiple de header files et peut être accompagné des commandes preprocessor \texttt{\#ifndef symbol \#define}


\section{Que faut-il placer dans un fichier d'entête ?}
Il faut placer la signature des méthodes qui sont utilisées dans le fichier source

\section{Quelle est l'utilité des mots-clef extern et static ?}
Le mot-clé \texttt{extern} permet de déclarer une variable à l'extérieur d'un fichier source pour qu'elle soit accessible par les autres fichiers sources\\
\texttt{static} définit le scope où la variable est accessible uniquement dans la classe ou dans la méthode qui l'utilise

\section{Comment faut-il procéder pour définir une constante en C ?}
\begin{itemize}
   \item \texttt{const type nom\_variable=valeur}
   \item \texttt{\#define NOM valeur}
\end{itemize}

\section{Quelle(s) différence(s) existe-t-il entre les instructions}
\begin{enumerate}
   \item   \#define MAX 10
   \item const int MAX=10
\end{enumerate}
La première est une commande preprocesseur et donc partout où l'on va utiliser MAX il sera remplacé par 10 et l'autre est une variable qui est constante donc elle a un type 


\section{Comment peut-on définir une énumération en C ? Quelle est son utilité ?}
\texttt{enum colors \{RED, YELLOW, BLUE\}} et permet d'initialiser une séquence de constantes qui pourra être utilisé plus tard

\section{Quelle(s) différence(s) existe-t-il entre une structure en C struct S\{\} et une classe en Java class C\{\} ?}
\texttt{struct S\{\}} permet de définir une structure par exemple un tableau avec plusieurs champ et chaque champ a un nom\\
\texttt{class C\{\}} permet de déclarer une class

\section{Comment faut-il procéder pour définir un tableau en C ? Peut-on lui donner des valeurs initiales lors de sa définition ?}
\texttt{int array\_declaration[10];} et avec l'affectation \texttt{int array\_declaration[]=\{10,9,8,7\};}

\section{Comment faut-il procéder pour obtenir le nombre d'éléments contenus dans un tableau ?}
\texttt{sizeof(array)/sizeof(array[0])}\\ \texttt{sizeof} retourne la taille de l'objet que l'on divise par le taille du type contenu
\end{document}
