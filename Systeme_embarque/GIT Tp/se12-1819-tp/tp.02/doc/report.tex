\input{Commands.tex}

\title{Système Embarqués II, Journal, TP.02:\\ Introduction à la programmation modulaire en C} 
\author{\textsl{Marc} \textsc{Roten} \\ \textsl{Sven} \textsc{Rouvinez}}
\date{}

\begin{document}
    \begin{titlepage}
        \begin{center}
            \includegraphics[scale=.3]{heia-fr-logo.png}\\[1.3cm]
            
            \rule{\linewidth}{0.3mm} \\[0.3cm]
            {\huge \bfseries Système embarqués \\[0.5cm]} 
           % {\Large Effet photoélectrique}\\[0.2cm]
            \rule{\linewidth}{0.3mm} \\[0.8cm]
            \noindent
            \begin{minipage}[t]{0.4\textwidth}
                \begin{flushleft} \large
                    \emph{Auteurs :}\\
                    \theauthor
                \end{flushleft}
            \end{minipage}
            \begin{minipage}[t]{0.4\textwidth} 
                \begin{flushright} \large
                    \emph{Professeur:}\\
                    \textsl{Daniel} \textsc{Gachet}\\ 
                \end{flushright} 
                \vfill
            \end{minipage}\\[1.3cm]
            \includegraphics[scale=0.6]{1.JPG}\\[1.5cm]
            \vspace*{1\baselineskip}
            \today \\[0.7cm]
        \end{center}
    \end{titlepage}
    \tableofcontents
    \clearpage
% \insertImage{Img/1.PNG}{echelle pour l'image (source = 1)}{texte dessous l'image}{référence vers l'objet}

\section{Pourrait-on se passer des fichiers d'entête (header files) en C ?} 
Oui il est possible de se passer des fichiers d'entête, il suffirait de mettre les signatures dans les fichiers source tout en haut

\section{\#pragma once}
Sur de ça? ==> Il permet d'éviter un import multiple de header files et peut être accompagné des commandes preprocessor \texttt{\#ifndef symbol \#define}

Cela permet de vérifier si le fichier n'a pas déja été importé. Si tel est le cas, une erreur sera générée.

\section{Que faut-il placer dans un fichier d'entête ?}
Il faut placer la signature des méthodes avec les bons types de retour pour les méthodes qui sont utilisées dans le fichier source (.c)

\section{Quelle est l'utilité des mots-clef extern et static ?}
Le mot-clé \texttt{extern} permet de déclarer une variable à l'extérieur d'un fichier source pour qu'elle soit accessible par les autres fichiers sources\\
\texttt{static} définit le scope où la variable est accessible uniquement dans la classe ou dans la méthode qui l'utilise

\section{Comment faut-il procéder pour définir une constante en C ?}
\begin{itemize}
   \item \texttt{const type nom\_variable=valeur}
   \item \texttt{\#define NOM valeur}
\end{itemize}

\section{Quelle(s) différence(s) existe-t-il entre les instructions}
\begin{enumerate}
   \item   \#define MAX 10
   \item const int MAX=10
\end{enumerate}
La première est une commande,  preprocesseur et donc partout où l'on va utiliser MAX il sera remplacé par 10, mais ne possède pas de type, donc peu importe que l'on utilise MAX pour un int, un double un long, il sera remplacé dans tous les cas par 10.

Et l'autre est une variable qui est constante donc elle a un type.  


\section{Comment peut-on définir une énumération en C ? Quelle est son utilité ?}
\texttt{enum colors \{RED, YELLOW, BLUE\}} et permet d'initialiser une séquence de constantes qui pourra être utilisé plus tard. Dans notre travail pratique on réalise un enum sur les différents états avec notre encodeur, et on passe via nos méthodes au travers de notre énum pour incrémenter ou décrémenter notre compteur.\\

On peut aussi rajouter que:
\begin{itemize}
   \item un Enum est un bon moyen d'avoir un code parlant sans avoir à recourir à des commentaires longs et fastidieux.
   \item Une économie non négligeable d'espace mémoire, très important en système embarqué.
   \item C'est aussi une garantie d'avoir des sorties stables si on alterne parmis des états connus d'une FSM (Finite State Machine)\\
\end{itemize}


\section{Quelle(s) différence(s) existe-t-il entre une structure en C struct S\{\} et une classe en Java class C\{\} ?}
\texttt{struct S\{\}} permet de définir une structure par exemple un tableau avec plusieurs champ et chaque champ a un nom, ou on peut représenter un \\
\texttt{class C\{\}} permet de déclarer une class, il n'existe pas de class en C, l'équivalent est \texttt{struct} et il n'y a pas de différence entre une \texttt{struct} et une class excepté la notion d'objet en Java qu'il n'y a pas en C

\section{Comment faut-il procéder pour définir un tableau en C ? Peut-on lui donner des valeurs initiales lors de sa définition ?}
\texttt{int array\_declaration[10];} et avec l'affectation \texttt{int array\_declaration[]=\{10,9,8,7\};}

\section{Comment faut-il procéder pour obtenir le nombre d'éléments contenus dans un tableau ?}
\texttt{sizeof(array)/sizeof(array[0])}\\ \texttt{sizeof} retourne la taille de l'objet que l'on divise par le taille du type contenu
\end{document}
